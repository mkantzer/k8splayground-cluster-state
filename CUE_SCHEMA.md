# Cue Schema

While this repository is responsible for defining, consuming, transforming, and rendering various schema, it also has its own internal data structure that it uses to manage all of that. This document provides information about that structure. 

## Background

Cuelang is not a traditional programming language. It is not Turing complete, nor is it designed to act as a "function", where it's passed some other input and then runs specific logic on it. All cue evaluations execute using the same binary, which doesn't contain any information about your data processing. 

Rather, it is a _data_ and _configuration_ language. You can think of it like JSON, if you could put rules and types and constraints _in the JSON itself_, instead of just into whatever application creates or consumes it. 

It's also a superset of JSON: any JSON data can be trivially represented as cuelang. 

Because Cue operates as a data language, all configuration, schema, validation, value, and inference information must be present in the same "workspace" at the same time. The logic is a _part_ of the data, not a separate entity. 

As a result, we do not define our input and output objects directly at the root level. Rather, we do something akin to namespacing, by nesting those within containing blocks, allowing us to more trivially operate and transform them. 

This document serves as a guide to that organization and its subcomponents, as well as explanations of how they are used and the logic behind them. 

## `kubernetes:`

The top level `kubernetes:` object holds direct cuelang representations of kubernetes manifests, under a specific structure of sub-objects. These are organized together to provided simplified access and transformation for all defined objects. 

`kubernetes:` also acts as the source from which the YAML stream generated by `cue dump` originates (albeit with an intermediate step. See `k8sObjects:`)

The organization of this top-level object is as follows:

`kubernetes: [strings.ToLower(Kind)] : [metadata.name]: {<manifest>}`

By grouping by `kind`, we are able to trivially specify that all objects are valid examples of  Kubernetes objects (eg: all the fields in a deployment are fields that are supposed to be there, and of the correct type). We can also put in system-wide required configuration or defaults (every pod must run as non-root, pods without resource requests or limits get defaults automatically).

By further grouping by object name, we can do searches and validations that require access to a specific object, without needing any list comprehension filters. There may be cases where we need to filter by something other than name, but this is likely the most common.

## `mikeApp:`

This object contains any definitions for an abstraction layer around kubernetes manifests. You can think of it kind of like the `values.yml` of a helm chart: it's a simplified structured input used to programmatically generate kubernetes manifests. See `WHY_NOT_HELM.md` for information on why I don't just use helm for this.

The top level `mikeApp:` object directly contains the `#MikeApp` schema (see `schema/mikeApp/<some version>/interface.cue` for the actual spec). Note that this object _by itself_ does not generate objects in the `kubernetes:` top-level object, but is instead _just_ a definition. See `appGenerator:`

## `appGenerator:`

This object uses the `mikeApp:` object to generate kubernetes objects. It uses the [function pattern](https://cuetorials.com/patterns/functions/) for this. It outputs a field `appGenerator.out.kubernetes`, which is formatted exactly like the top-level `kubernetes:` object, and used to add entries to same, as:
```
appGenerator: mikeApp_v1alpha1.#Generator & {in: {
  metadata: mikeApp.metadata
  spec:     mikeApp.spec
}}
kubernetes: {
	appGenerator.out.kubernetes
	...
}
```


## `k8sObjects:`:

This object essentially loops over `kubernetes:`'s nested fields `[kind]` and `[name]` to produce a single, flat list of generated objects that can be passed directly into `yaml.MarshalStream(k8sObjects)`. 

Its implementation is simple:
```
k8sObjects: [
	for kind in kubernetes
	for object in kind {object},
]
```