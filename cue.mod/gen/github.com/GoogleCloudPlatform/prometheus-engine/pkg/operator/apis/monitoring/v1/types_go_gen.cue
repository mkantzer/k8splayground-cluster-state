// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/GoogleCloudPlatform/prometheus-engine/pkg/operator/apis/monitoring/v1

package v1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	prommodel "github.com/prometheus/common/model"
)

// OperatorConfig defines configuration of the gmp-operator.
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:storageversion
#OperatorConfig: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Rules specifies how the operator configures and deployes rule-evaluator.
	rules?: #RuleEvaluatorSpec @go(Rules)

	// Collection specifies how the operator configures collection.
	collection?: #CollectionSpec @go(Collection)

	// ManagedAlertmanager holds information for configuring the managed instance of Alertmanager.
	// +kubebuilder:default={configSecret: {name: alertmanager, key: alertmanager.yaml}}
	managedAlertmanager?: null | #ManagedAlertmanagerSpec @go(ManagedAlertmanager,*ManagedAlertmanagerSpec)

	// Features holds configuration for optional managed-collection features.
	features?: #OperatorFeatures @go(Features)
}

// OperatorConfigList is a list of OperatorConfigs.
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#OperatorConfigList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#OperatorConfig] @go(Items,[]OperatorConfig)
}

// RuleEvaluatorSpec defines configuration for deploying rule-evaluator.
#RuleEvaluatorSpec: {
	// ExternalLabels specifies external labels that are attached to any rule
	// results and alerts produced by rules. The precedence behavior matches that
	// of Prometheus.
	externalLabels?: {[string]: string} @go(ExternalLabels,map[string]string)

	// QueryProjectID is the GCP project ID to evaluate rules against.
	// If left blank, the rule-evaluator will try attempt to infer the Project ID
	// from the environment.
	queryProjectID?: string @go(QueryProjectID)

	// The base URL used for the generator URL in the alert notification payload.
	// Should point to an instance of a query frontend that gives access to queryProjectID.
	generatorUrl?: string @go(GeneratorURL)

	// Alerting contains how the rule-evaluator configures alerting.
	alerting?: #AlertingSpec @go(Alerting)

	// A reference to GCP service account credentials with which the rule
	// evaluator container is run. It needs to have metric read permissions
	// against queryProjectId and metric write permissions against all projects
	// to which rule results are written.
	// Within GKE, this can typically be left empty if the compute default
	// service account has the required permissions.
	credentials?: null | v1.#SecretKeySelector @go(Credentials,*v1.SecretKeySelector)
}

// CollectionSpec specifies how the operator configures collection of metric data.
#CollectionSpec: {
	// ExternalLabels specifies external labels that are attached to all scraped
	// data before being written to Cloud Monitoring. The precedence behavior matches that
	// of Prometheus.
	externalLabels?: {[string]: string} @go(ExternalLabels,map[string]string)

	// Filter limits which metric data is sent to Cloud Monitoring.
	filter?: #ExportFilters @go(Filter)

	// A reference to GCP service account credentials with which Prometheus collectors
	// are run. It needs to have metric write permissions for all project IDs to which
	// data is written.
	// Within GKE, this can typically be left empty if the compute default
	// service account has the required permissions.
	credentials?: null | v1.#SecretKeySelector @go(Credentials,*v1.SecretKeySelector)

	// Configuration to scrape the metric endpoints of the Kubelets.
	kubeletScraping?: null | #KubeletScraping @go(KubeletScraping,*KubeletScraping)

	// Compression enables compression of metrics collection data
	compression?: #CompressionType @go(Compression)
}

// OperatorFeatures holds configuration for optional managed-collection features.
#OperatorFeatures: {
	// Configuration of target status reporting.
	targetStatus?: #TargetStatusSpec @go(TargetStatus)
}

// TargetStatusSpec holds configuration for target status reporting.
#TargetStatusSpec: {
	// Enable target status reporting.
	enabled?: bool @go(Enabled)
}

// +kubebuilder:validation:Enum=none;gzip
#CompressionType: string

// KubeletScraping allows enabling scraping of the Kubelets' metric endpoints.
#KubeletScraping: {
	// The interval at which the metric endpoints are scraped.
	interval: string @go(Interval)
}

// ExportFilters provides mechanisms to filter the scraped data that's sent to GMP.
#ExportFilters: {
	// A list Prometheus time series matchers. Every time series must match at least one
	// of the matchers to be exported. This field can be used equivalently to the match[]
	// parameter of the Prometheus federation endpoint to selectively export data.
	// Example: `["{job!='foobar'}", "{__name__!~'container_foo.*|container_bar.*'}"]`
	matchOneOf?: [...string] @go(MatchOneOf,[]string)
}

// AlertingSpec defines alerting configuration.
#AlertingSpec: {
	// Alertmanagers contains endpoint configuration for designated Alertmanagers.
	alertmanagers?: [...#AlertmanagerEndpoints] @go(Alertmanagers,[]AlertmanagerEndpoints)
}

// ManagedAlertmanagerSpec holds configuration information for the managed
// Alertmanager instance.
#ManagedAlertmanagerSpec: {
	// ConfigSecret refers to the name of a single-key Secret in the public namespace that
	// holds the managed Alertmanager config file.
	configSecret?: null | v1.#SecretKeySelector @go(ConfigSecret,*v1.SecretKeySelector)
}

// AlertmanagerEndpoints defines a selection of a single Endpoints object
// containing alertmanager IPs to fire alerts against.
#AlertmanagerEndpoints: {
	// Namespace of Endpoints object.
	namespace: string @go(Namespace)

	// Name of Endpoints object in Namespace.
	name: string @go(Name)

	// Port the Alertmanager API is exposed on.
	port: intstr.#IntOrString @go(Port)

	// Scheme to use when firing alerts.
	scheme?: string @go(Scheme)

	// Prefix for the HTTP path alerts are pushed to.
	pathPrefix?: string @go(PathPrefix)

	// TLS Config to use for alertmanager connection.
	tls?: null | #TLSConfig @go(TLS,*TLSConfig)

	// Authorization section for this alertmanager endpoint
	authorization?: null | #Authorization @go(Authorization,*Authorization)

	// Version of the Alertmanager API that rule-evaluator uses to send alerts. It
	// can be "v1" or "v2".
	apiVersion?: string @go(APIVersion)

	// Timeout is a per-target Alertmanager timeout when pushing alerts.
	timeout?: string @go(Timeout)
}

// Authorization specifies a subset of the Authorization struct, that is
// safe for use in Endpoints (no CredentialsFile field).
#Authorization: {
	// Set the authentication type. Defaults to Bearer, Basic will cause an
	// error
	type?: string @go(Type)

	// The secret's key that contains the credentials of the request
	credentials?: null | v1.#SecretKeySelector @go(Credentials,*v1.SecretKeySelector)
}

// SafeTLSConfig specifies TLS configuration parameters from Kubernetes resources.
#TLSConfig: {
	// Struct containing the CA cert to use for the targets.
	ca?: null | #SecretOrConfigMap @go(CA,*SecretOrConfigMap)

	// Struct containing the client cert file for the targets.
	cert?: null | #SecretOrConfigMap @go(Cert,*SecretOrConfigMap)

	// Secret containing the client key file for the targets.
	keySecret?: null | v1.#SecretKeySelector @go(KeySecret,*v1.SecretKeySelector)

	// Used to verify the hostname for the targets.
	serverName?: string @go(ServerName)

	// Disable target certificate validation.
	insecureSkipVerify?: bool @go(InsecureSkipVerify)
}

// SecretOrConfigMap allows to specify data as a Secret or ConfigMap. Fields are mutually exclusive.
// Taking inspiration from prometheus-operator: https://github.com/prometheus-operator/prometheus-operator/blob/2c81b0cf6a5673e08057499a08ddce396b19dda4/Documentation/api.md#secretorconfigmap
#SecretOrConfigMap: {
	// Secret containing data to use for the targets.
	secret?: null | v1.#SecretKeySelector @go(Secret,*v1.SecretKeySelector)

	// ConfigMap containing data to use for the targets.
	configMap?: null | v1.#ConfigMapKeySelector @go(ConfigMap,*v1.ConfigMapKeySelector)
}

// PodMonitoringStatusContainer represents a Kubernetes CRD that monitors pods
// and contains a status sub-resource.
#PodMonitoringStatusContainer: _

// PodMonitoring defines monitoring for a set of pods, scoped to pods
// within the PodMonitoring's namespace.
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
#PodMonitoring: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Specification of desired Pod selection for target discovery by
	// Prometheus.
	spec: #PodMonitoringSpec @go(Spec)

	// Most recently observed status of the resource.
	// +optional
	status?: #PodMonitoringStatus @go(Status)
}

// PodMonitoringList is a list of PodMonitorings.
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#PodMonitoringList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#PodMonitoring] @go(Items,[]PodMonitoring)
}

// ClusterPodMonitoring defines monitoring for a set of pods, scoped to all
// pods within the cluster.
// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:scope=Cluster
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
#ClusterPodMonitoring: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Specification of desired Pod selection for target discovery by
	// Prometheus.
	spec: #ClusterPodMonitoringSpec @go(Spec)

	// Most recently observed status of the resource.
	// +optional
	status: #PodMonitoringStatus @go(Status)
}

// ClusterPodMonitoringList is a list of ClusterPodMonitorings.
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#ClusterPodMonitoringList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#ClusterPodMonitoring] @go(Items,[]ClusterPodMonitoring)
}

#EnvVarNodeName: "NODE_NAME"

// PodMonitoringSpec contains specification parameters for PodMonitoring.
#PodMonitoringSpec: {
	// Label selector that specifies which pods are selected for this monitoring
	// configuration.
	selector: metav1.#LabelSelector @go(Selector)

	// The endpoints to scrape on the selected pods.
	endpoints: [...#ScrapeEndpoint] @go(Endpoints,[]ScrapeEndpoint)

	// Labels to add to the Prometheus target for discovered endpoints.
	// The `instance` label is always set to `<pod_name>:<port>` or `<node_name>:<port>`
	// if the scraped pod is controlled by a DaemonSet.
	targetLabels?: #TargetLabels @go(TargetLabels)

	// Limits to apply at scrape time.
	limits?: null | #ScrapeLimits @go(Limits,*ScrapeLimits)
}

// ScrapeLimits limits applied to scraped targets.
#ScrapeLimits: {
	// Maximum number of samples accepted within a single scrape.
	// Uses Prometheus default if left unspecified.
	samples?: uint64 @go(Samples)

	// Maximum number of labels accepted for a single sample.
	// Uses Prometheus default if left unspecified.
	labels?: uint64 @go(Labels)

	// Maximum label name length.
	// Uses Prometheus default if left unspecified.
	labelNameLength?: uint64 @go(LabelNameLength)

	// Maximum label value length.
	// Uses Prometheus default if left unspecified.
	labelValueLength?: uint64 @go(LabelValueLength)
}

// ClusterPodMonitoringSpec contains specification parameters for PodMonitoring.
#ClusterPodMonitoringSpec: {
	// Label selector that specifies which pods are selected for this monitoring
	// configuration.
	selector: metav1.#LabelSelector @go(Selector)

	// The endpoints to scrape on the selected pods.
	endpoints: [...#ScrapeEndpoint] @go(Endpoints,[]ScrapeEndpoint)

	// Labels to add to the Prometheus target for discovered endpoints.
	// The `instance` label is always set to `<pod_name>:<port>` or `<node_name>:<port>`
	// if the scraped pod is controlled by a DaemonSet.
	targetLabels?: #TargetLabels @go(TargetLabels)

	// Limits to apply at scrape time.
	limits?: null | #ScrapeLimits @go(Limits,*ScrapeLimits)
}

// ScrapeEndpoint specifies a Prometheus metrics endpoint to scrape.
#ScrapeEndpoint: {
	// Name or number of the port to scrape.
	// The container metadata label is only populated if the port is referenced by name
	// because port numbers are not unique across containers.
	port: intstr.#IntOrString @go(Port)

	// Protocol scheme to use to scrape.
	scheme?: string @go(Scheme)

	// HTTP path to scrape metrics from. Defaults to "/metrics".
	path?: string @go(Path)

	// HTTP GET params to use when scraping.
	params?: {[string]: [...string]} @go(Params,map[string][]string)

	// Proxy URL to scrape through. Encoded passwords are not supported.
	proxyUrl?: string @go(ProxyURL)

	// Interval at which to scrape metrics. Must be a valid Prometheus duration.
	interval?: string @go(Interval)

	// Timeout for metrics scrapes. Must be a valid Prometheus duration.
	// Must not be larger then the scrape interval.
	timeout?: string @go(Timeout)

	// Relabeling rules for metrics scraped from this endpoint. Relabeling rules that
	// override protected target labels (project_id, location, cluster, namespace, job,
	// instance, or __address__) are not permitted. The labelmap action is not permitted
	// in general.
	metricRelabeling?: [...#RelabelingRule] @go(MetricRelabeling,[]RelabelingRule)
}

// TargetLabels configures labels for the discovered Prometheus targets.
#TargetLabels: {
	// Pod metadata labels that are set on all scraped targets.
	// Permitted keys are `pod`, `container`, and `node` for PodMonitoring and
	// `pod`, `container`, `node`, and `namespace` for ClusterPodMonitoring. The `container`
	// label is only populated if the scrape port is referenced by name.
	// Defaults to [pod, container] for PodMonitoring and [namespace, pod, container]
	// for ClusterPodMonitoring.
	// If set to null, it will be interpreted as the empty list for PodMonitoring
	// and to [namespace] for ClusterPodMonitoring. This is for backwards-compatibility
	// only.
	metadata?: null | [...string] @go(Metadata,*[]string)

	// Labels to transfer from the Kubernetes Pod to Prometheus target labels.
	// Mappings are applied in order.
	fromPod?: [...#LabelMapping] @go(FromPod,[]LabelMapping)
}

// LabelMapping specifies how to transfer a label from a Kubernetes resource
// onto a Prometheus target.
#LabelMapping: {
	// Kubenetes resource label to remap.
	from: string @go(From)

	// Remapped Prometheus target label.
	// Defaults to the same name as `From`.
	to?: string @go(To)
}

// RelabelingRule defines a single Prometheus relabeling rule.
#RelabelingRule: {
	// The source labels select values from existing labels. Their content is concatenated
	// using the configured separator and matched against the configured regular expression
	// for the replace, keep, and drop actions.
	sourceLabels?: [...string] @go(SourceLabels,[]string)

	// Separator placed between concatenated source label values. Defaults to ';'.
	separator?: string @go(Separator)

	// Label to which the resulting value is written in a replace action.
	// It is mandatory for replace actions. Regex capture groups are available.
	targetLabel?: string @go(TargetLabel)

	// Regular expression against which the extracted value is matched. Defaults to '(.*)'.
	regex?: string @go(Regex)

	// Modulus to take of the hash of the source label values.
	modulus?: uint64 @go(Modulus)

	// Replacement value against which a regex replace is performed if the
	// regular expression matches. Regex capture groups are available. Defaults to '$1'.
	replacement?: string @go(Replacement)

	// Action to perform based on regex matching. Defaults to 'replace'.
	action?: string @go(Action)
}

#ScrapeEndpointStatus: {
	// The name of the ScrapeEndpoint.
	name: string @go(Name)

	// Total number of active targets.
	activeTargets?: int64 @go(ActiveTargets)

	// Total number of active, unhealthy targets.
	unhealthyTargets?: int64 @go(UnhealthyTargets)

	// Last time this status was updated.
	lastUpdateTime?: metav1.#Time @go(LastUpdateTime)

	// A fixed sample of targets grouped by error type.
	sampleGroups?: [...#SampleGroup] @go(SampleGroups,[]SampleGroup)

	// Fraction of collectors included in status, bounded [0,1].
	// Ideally, this should always be 1. Anything less can
	// be considered a problem and should be investigated.
	collectorsFraction?: string @go(CollectorsFraction)
}

#SampleGroup: {
	// Targets emitting the error message.
	sampleTargets?: [...#SampleTarget] @go(SampleTargets,[]SampleTarget)

	// Total count of similar errors.
	// +optional
	count?: null | int32 @go(Count,*int32)
}

#SampleTarget: {
	// The label set, keys and values, of the target.
	labels?: prommodel.#LabelSet @go(Labels)

	// Error message.
	lastError?: null | string @go(LastError,*string)

	// Scrape duration in seconds.
	lastScrapeDurationSeconds?: string @go(LastScrapeDurationSeconds)

	// Health status.
	health?: string @go(Health)
}

// PodMonitoringStatus holds status information of a PodMonitoring resource.
#PodMonitoringStatus: {
	// The generation observed by the controller.
	// +optional
	observedGeneration?: int64 @go(ObservedGeneration)

	// Represents the latest available observations of a podmonitor's current state.
	conditions?: [...#MonitoringCondition] @go(Conditions,[]MonitoringCondition)

	// Represents the latest available observations of target state for each ScrapeEndpoint.
	endpointStatuses?: [...#ScrapeEndpointStatus] @go(EndpointStatuses,[]ScrapeEndpointStatus)
}

// MonitoringConditionType is the type of MonitoringCondition.
#MonitoringConditionType: string // #enumMonitoringConditionType

#enumMonitoringConditionType:
	#ConfigurationCreateSuccess

// ConfigurationCreateSuccess indicates that the config generated from the
// monitoring resource was created successfully.
#ConfigurationCreateSuccess: #MonitoringConditionType & "ConfigurationCreateSuccess"

// MonitoringCondition describes a condition of a PodMonitoring.
#MonitoringCondition: {
	type: #MonitoringConditionType @go(Type)

	// Status of the condition, one of True, False, Unknown.
	status: v1.#ConditionStatus @go(Status)

	// The last time this condition was updated.
	// +optional
	lastUpdateTime?: metav1.#Time @go(LastUpdateTime)

	// Last time the condition transitioned from one status to another.
	// +optional
	lastTransitionTime?: metav1.#Time @go(LastTransitionTime)

	// The reason for the condition's last transition.
	// +optional
	reason?: string @go(Reason)

	// A human-readable message indicating details about the transition.
	// +optional
	message?: string @go(Message)
}

// Rules defines Prometheus alerting and recording rules that are scoped
// to the namespace of the resource. Only metric data from this namespace is processed
// and all rule results have their project_id, cluster, and namespace label preserved
// for query processing.
// If the location label is not preserved by the rule, it defaults to the cluster's location.
//
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
#Rules: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Specification of rules to record and alert on.
	spec: #RulesSpec @go(Spec)

	// Most recently observed status of the resource.
	// +optional
	status: #RulesStatus @go(Status)
}

// RulesList is a list of Rules.
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#RulesList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#Rules] @go(Items,[]Rules)
}

// ClusterRules defines Prometheus alerting and recording rules that are scoped
// to the current cluster. Only metric data from the current cluster is processed
// and all rule results have their project_id and cluster label preserved
// for query processing.
// If the location label is not preserved by the rule, it defaults to the cluster's location.
//
// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:scope=Cluster
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
#ClusterRules: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Specification of rules to record and alert on.
	spec: #RulesSpec @go(Spec)

	// Most recently observed status of the resource.
	// +optional
	status: #RulesStatus @go(Status)
}

// ClusterRulesList is a list of ClusterRules.
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#ClusterRulesList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#ClusterRules] @go(Items,[]ClusterRules)
}

// GlobalRules defines Prometheus alerting and recording rules that are scoped
// to all data in the queried project.
// If the project_id or location labels are not preserved by the rule, they default to
// the values of the cluster.
//
// +genclient
// +genclient:nonNamespaced
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:resource:scope=Cluster
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
#GlobalRules: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Specification of rules to record and alert on.
	spec: #RulesSpec @go(Spec)

	// Most recently observed status of the resource.
	// +optional
	status: #RulesStatus @go(Status)
}

// GlobalRulesList is a list of GlobalRules.
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#GlobalRulesList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#GlobalRules] @go(Items,[]GlobalRules)
}

// RulesSpec contains specification parameters for a Rules resource.
#RulesSpec: {
	// A list of Prometheus rule groups.
	groups: [...#RuleGroup] @go(Groups,[]RuleGroup)
}

// RuleGroup declares rules in the Prometheus format:
// https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/
#RuleGroup: {
	// The name of the rule group.
	name: string @go(Name)

	// The interval at which to evaluate the rules. Must be a valid Prometheus duration.
	interval: string @go(Interval)

	// A list of rules that are executed sequentially as part of this group.
	rules: [...#Rule] @go(Rules,[]Rule)
}

// Rule is a single rule in the Prometheus format:
// https://prometheus.io/docs/prometheus/latest/configuration/recording_rules/
#Rule: {
	// Record the result of the expression to this metric name.
	// Only one of `record` and `alert` must be set.
	record?: string @go(Record)

	// Name of the alert to evaluate the expression as.
	// Only one of `record` and `alert` must be set.
	alert?: string @go(Alert)

	// The PromQL expression to evaluate.
	expr: string @go(Expr)

	// The duration to wait before a firing alert produced by this rule is sent to Alertmanager.
	// Only valid if `alert` is set.
	for?: string @go(For)

	// A set of labels to attach to the result of the query expression.
	labels?: {[string]: string} @go(Labels,map[string]string)

	// A set of annotations to attach to alerts produced by the query expression.
	// Only valid if `alert` is set.
	annotations?: {[string]: string} @go(Annotations,map[string]string)
}

// RulesStatus contains status information for a Rules resource.
#RulesStatus: {
}
